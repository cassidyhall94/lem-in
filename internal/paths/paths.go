package paths

import (
	"sort"

	"git.learn.01founders.co/Cassidy.Hall94/lem-in/internal/structs"
)

// FindAllPaths saves all valid paths from start to end
func FindAllPaths(farm structs.Farm) []*structs.PathStruct {
	pathStruct := []*structs.PathStruct{}

	for _, farmRoom := range farm.Rooms {
		if farmRoom.IsStart {
			_, paths, _, _ := findValidPath(farmRoom, []string{}, [][]*structs.Room{}, []*structs.Room{})
			for _, p := range paths {
				pathStruct = append(pathStruct, &structs.PathStruct{Path: p})
			}
		}
	}
	return pathStruct
}

// findValidPath looks in a room for its links, it then asks itself about those links returning a slice of visited rooms and a slice of paths
// setting the returned bool indicates that we're rolling back up the tree or graph
func findValidPath(room *structs.Room, visited []string, paths [][]*structs.Room, path []*structs.Room) ([]string, [][]*structs.Room, []*structs.Room, bool) {
	path = append(path, room)
	visited = append(visited, room.Name)

	if room.IsEnd {
		return nil, append(paths, path), nil, true
	}

	rollup := false

	for _, l := range room.Links {
		if len(l.Links) == 1 && l.Links[0].Name == room.Name && !l.IsEnd {
			continue
		} else if visitedRoom(visited, l) {
			continue
		}

		newVisited := make([]string, len(visited))
		copy(newVisited, visited)
		newPath := make([]*structs.Room, len(path))
		copy(newPath, path)

		_, ps, _, r := findValidPath(l, newVisited, paths, newPath)
		if r {
			rollup = r
			paths = ps
		}
	}

	return visited, paths, path, rollup
}

func visitedRoom(visited []string, room *structs.Room) bool {
	for _, roomsVisited := range visited {
		if roomsVisited == room.Name {
			return true
		}
	}
	return false
}

func SortPaths(allPaths []*structs.PathStruct) []*structs.PathStruct {
	sort.Slice(allPaths, func(i, j int) bool {
		shortToLong := len(allPaths[i].Path) < len(allPaths[j].Path)
		return shortToLong
	})
	return allPaths
}

// TrimPaths removes overlapping paths (except start/end rooms)
// It loops over allPaths for each path, stores the path in a helper variable and then in the next loop compares path with against the helper variable, if the helper variable does match path, it won't return the path
func TrimPaths(allPaths []*structs.PathStruct) []*structs.PathStruct {
	trimmedPaths := []*structs.PathStruct{}
	helper := []*structs.Room{}
	for _, path := range allPaths {
		if len(path.Path) == 2 {
			trimmedPaths = append(trimmedPaths, path)
			continue
		}
		pathToAppend := true
		for _, room := range path.Path {
			if contains(helper, room) {
				pathToAppend = false
				break
			}
			if !room.IsStart && !room.IsEnd {
				helper = append(helper, room)
			}
		}
		if pathToAppend {
			trimmedPaths = append(trimmedPaths, path)
		}
	}
	return trimmedPaths
}

// contains function checks to see if a room has been added to the path, if it has it will not return the path to the trimmedPaths
func contains(s []*structs.Room, str *structs.Room) bool {
	for _, v := range s {
		if v == str {
			return true
		}
	}
	return false
}

// mapOfStringsToPaths holds a mapping of arbitrary strings to paths
type mapOfStringsToPaths map[string][]*structs.Room

// MapPathsToStrings creates an string of runes
// where the runes are arbitrary references to paths in the returned map
// this is used to make calculating all of the permutations of rooms simpler
func MapPathsToStrings(allPaths [][]*structs.Room) (map[string][]*structs.Room, string) {
	lookupMap, sortString := map[string][]*structs.Room{}, ""
	letter := func(i int) string {
		return string(rune(i + 33))
	}
	for i, path := range allPaths {
		lookupMap[letter(i)] = path
		sortString = sortString + letter(i)
	}
	return lookupMap, sortString
}

// GetPathsFromStrings reassembles a slice of paths using
// the map generated by MapPathsToStrings and a permutation of the sortString
func GetPathsFromStrings(lookupMap map[string][]*structs.Room, sortString string) [][]*structs.Room {
	allPaths := [][]*structs.Room{}
	for _, r := range sortString {
		allPaths = append(allPaths, lookupMap[string(r)])
	}
	return allPaths
}

// Permutations gets all permutations of a string up to maxPermutations
// for large strings reducing maxPermutations can improve performance at the cost of correctness
func PermutationsIter(str string, maxPermutations int) []string {
	var count = 0
	ret := []string{}
	temp := []rune(str)
	// if there is only one character then there is one permutation, returning early prevents later panics
	if len(temp) == 1 {
		return []string{str}
	}
	// sort the string in ascending rune value
	sort.Slice(temp, func(i, j int) bool {
		return temp[i] < temp[j]
	})
	index, lowest := 0, 0
	for {
		// break here for performance with large strings
		if count > maxPermutations {
			break
		}
		count++
		// find the rightmost rune which is smaller than its next neighbour
		for i := 0; i < len(temp)-1; i++ {
			if temp[i] < temp[i+1] {
				lowest = i
			}
		}
		index = lowest
		// find the smallest rune in temp that is still larger than temp[index]
		j := findCeiling(temp, index)
		if j == index {
			break
		}
		// swap temp[index] with temp[j] so that temp[index] is now the next largest from temp[j]
		swap(temp, index, j)
		// now sort everything after temp[index], this is to prepare for the next loop
		b := temp[index+1:]
		sort.Slice(b, func(i, j int) bool {
			return b[i] < b[j]
		})
		a := string(temp[0:index+1]) + string(b)
		temp = []rune(a)
		// append our current permutation to ret
		ret = append(ret, string(temp))
		// the next loop will/should operate on temp[index+1:]...
	}
	return ret
}

// swap replaces r[i] with r[j] and visa versa
func swap(r []rune, i, j int) string {
	r[i], r[j] = r[j], r[i]
	return string(r)
}

// findCeiling finds the next smallest rune after temp[index]
func findCeiling(temp []rune, index int) int {
	k := index
	test := temp[index]
	for k < len(temp)-1 {
		if temp[index] < temp[k+1] {
			index = k + 1
			break
		}
		k++
	}
	k = index
	for k < len(temp)-1 {
		if (temp[index] > temp[k+1]) && (temp[k+1] > test) {
			index = k + 1
		}
		k++
	}
	return index
}

func GetSliceOfRoomNames(rooms []*structs.Room) []string {
	ret := []string{}
	for _, r := range rooms {
		ret = append(ret, r.Name)
	}
	return ret
}

func GetSliceOfPathNames(paths []*structs.PathStruct) []string {
	ret := []string{}
	for _, path := range paths {
		for _, pathInfo := range path.Path {
			ret = append(ret, pathInfo.Name)
		}
	}
	return ret
}
